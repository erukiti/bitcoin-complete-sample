#! /usr/bin/env node

const {BitcoinPeer} = require('../src/chap-p2p/bitcoin-peer')
const {encodeVersion} = require('../src/chap-p2p/packet/version')
const {conf} = require('../src/index')

const peer = new BitcoinPeer()

const blocks = {}
const txs = {}

peer.onCommand('version', payload => {
  console.log(payload)
  // payload.startHeight
})

peer.onCommand('sendcmpct', payload => {
  console.log('  sendcmpct', payload)
})

peer.onCommand('feefilter', payload => {
  console.log('  feefilter', payload)
})

peer.onCommand('inv', payload => {
  console.log('  inv', payload)
  peer.send('getdata', payload)

  payload.forEach(({type, hash}) => {
    switch (type) {
      case 'MSG_BLOCK': {
        console.log('  Block ID: ', hash)
        break
      }
      default: {
        console.log('  inv:', type, hash)
      }
    }
  })
})

peer.onCommand('ping', payload => {
  peer.send('pong', payload)
})

const onTx = tx => {
  if (tx.id in txs) {
    console.warn(`warn: Tx ${tx.id} is already exists.`)
  } else {
    txs[tx.id] = tx
    console.log('  Tx', tx)
  }
}

const onBlock = block => {
  if (block.id in blocks) {
    console.warn(`warn: Block ${block.id} is already exists.`)
  } else {
    blocks[block.id] = block
    block.getTransactions().forEach(tx => onTx(tx))
    console.log('  Block', block)
  }
}

peer.onCommand('block', payload => {
  onBlock(payload)
})

const body = async () => {
  await peer.connect()
  peer.send('version', {})
  peer.send('verack')

  peer.send('getblocks', {
    ids: [conf.genesisBlock],
    stopHash: Buffer.alloc(32).fill(0)
  })
}

body()

